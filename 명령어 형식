1) 0-주소 명령어

: 연산코드부만 존재하고 주소를 지정하는 오퍼랜드가 존재하지 않는 명령어로서 모든 연산은 스택포인터가 가리키는 오퍼랜드롤 이용하여 명령을 수행한다. 
다른 주소 명령어들과 달리 STOR명령어를 사용하지 않는다.(PUSH/POP 사용)

 

 

2) 1-주소 명령어

: 오퍼랜드를 한 개만 포함하는 명령어로서, 오퍼랜드는 주소를 저장한다. 누산기(AC)를 이용하여 처리하며 수행 결과 또한 누산기에 저장된다.


ex)  LOAD X               ;AC←M[X] (X번지의 데이터를 누산기에 저장해라)         

 

 

3) 2-주소 명령어

: 오퍼랜드 두 개를 포함하는 명령어로서, 오퍼랜드는 2개 모두 주소를 저장한다. 실행 속도가 빠르며 기억 장소 효율이 좋다. 연산 결과는 한 쪽에 저장되어 다른 한 쪽의 자료는 사라진다.


ex)  MOV X, Y               ;M[X]←M[Y](X, Y는 주소를 나타낸다. Y번지의 기억장치 데이터를 X번지의 기억장치로 이동시켜라)

 

 

 

3) 3-주소 명령어

: 오퍼랜드 세 개를 포함하는 명령어로서, 레지스터의 주소를 저장하는 명령어 형식이다. 연산 결과를 한 영역을 사용하여 원래의 자료가 사라지지 않는다.
명령어 인출에 필요한 주기억장치 접근 횟수가 적다. 대신 하나의 명령어를 수행하는 시간이 길어진다.


 

ex)  ADD X, Y, Z               ;M[X]←M[Y]+M[Z] (X,Y,Z는 각각 주소를 나타낸다. Y와 Z번지의 데이터를 더하여 X번지에 저장해라)
